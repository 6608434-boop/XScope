#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
================================================================================
ФАЙЛ: models/user.py
НАЗНАЧЕНИЕ: Модель пользователя
АВТОР: Oliver Vance
ДАТА: 2026-02-14

ОПИСАНИЕ:
    Работа с таблицей users:
    - Создание пользователя
    - Поиск по username
    - Управление 2FA
    - Проверка пароля

ИСПОЛЬЗОВАНИЕ:
    from models.user import User

    # Создать пользователя
    user_id = User.create('username', 'hash123')

    # Найти по username
    user = User.get_by_username('username')

ИСТОРИЯ ИЗМЕНЕНИЙ:
    2026-02-14 - Oliver - создание
================================================================================
"""

from typing import Optional, Dict, Any

from utils.db import get_db_connection, execute_dict_one, execute_insert
from utils.security import check_password
from models.base import BaseModel

import logging

logger = logging.getLogger(__name__)


class User(BaseModel):
    """
    Модель пользователя.

    Таблица: users
    Поля:
        id: SERIAL PRIMARY KEY
        username: VARCHAR(80) UNIQUE NOT NULL
        password_hash: VARCHAR(200) NOT NULL
        twofa_secret: VARCHAR(32)
        twofa_enabled: BOOLEAN DEFAULT FALSE
        created_at: TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    """

    table_name = 'users'

    @classmethod
    def get_by_username(cls, username: str) -> Optional[Dict[str, Any]]:
        """
        Находит пользователя по имени.

        Args:
            username: Имя пользователя

        Returns:
            Optional[Dict]: Данные пользователя или None
        """
        conn = get_db_connection()
        try:
            query = "SELECT * FROM users WHERE username = %s"
            user = execute_dict_one(conn, query, (username,))
            logger.debug(f"Поиск пользователя '{username}': {'найден' if user else 'не найден'}")
            return user
        finally:
            conn.close()

    @classmethod
    def create(cls, username: str, password_hash: str, twofa_secret: Optional[str] = None) -> int:
        """
        Создаёт нового пользователя.

        Args:
            username: Имя пользователя
            password_hash: Хеш пароля
            twofa_secret: Секрет для 2FA (опционально)

        Returns:
            int: ID созданного пользователя

        Raises:
            Exception: Если пользователь уже существует
        """
        conn = get_db_connection()
        try:
            # Проверяем, не занят ли username
            existing = cls.get_by_username(username)
            if existing:
                raise ValueError(f"Пользователь '{username}' уже существует")

            # Создаём пользователя
            user_id = execute_insert(conn, 'users', {
                'username': username,
                'password_hash': password_hash,
                'twofa_secret': twofa_secret,
                'twofa_enabled': twofa_secret is not None
            })

            conn.commit()
            logger.info(f"✅ Создан пользователь: {username} (ID: {user_id})")
            return user_id

        except Exception as e:
            conn.rollback()
            logger.error(f"❌ Ошибка создания пользователя {username}: {e}")
            raise
        finally:
            conn.close()

    @classmethod
    def verify_password(cls, username: str, password: str) -> Optional[Dict[str, Any]]:
        """
        Проверяет пароль пользователя.

        Args:
            username: Имя пользователя
            password: Пароль для проверки

        Returns:
            Optional[Dict]: Данные пользователя если пароль верный, иначе None
        """
        user = cls.get_by_username(username)

        if not user:
            logger.debug(f"Попытка входа с несуществующим username: {username}")
            return None

        if check_password(user['password_hash'], password):
            logger.info(f"✅ Успешный вход: {username}")
            return user
        else:
            logger.warning(f"❌ Неверный пароль для: {username}")
            return None

    @classmethod
    def enable_2fa(cls, user_id: int, secret: str) -> bool:
        """
        Включает 2FA для пользователя.

        Args:
            user_id: ID пользователя
            secret: Секрет для 2FA

        Returns:
            bool: True если успешно
        """
        conn = get_db_connection()
        cur = conn.cursor()

        try:
            cur.execute("""
                UPDATE users
                SET twofa_secret = %s, twofa_enabled = TRUE
                WHERE id = %s
            """, (secret, user_id))

            conn.commit()
            logger.info(f"✅ 2FA включён для пользователя {user_id}")
            return True

        except Exception as e:
            conn.rollback()
            logger.error(f"❌ Ошибка включения 2FA для {user_id}: {e}")
            return False
        finally:
            cur.close()
            conn.close()

    @classmethod
    def disable_2fa(cls, user_id: int) -> bool:
        """
        Отключает 2FA для пользователя.

        Args:
            user_id: ID пользователя

        Returns:
            bool: True если успешно
        """
        conn = get_db_connection()
        cur = conn.cursor()

        try:
            cur.execute("""
                UPDATE users
                SET twofa_enabled = FALSE, twofa_secret = NULL
                WHERE id = %s
            """, (user_id,))

            conn.commit()
            logger.info(f"✅ 2FA отключён для пользователя {user_id}")
            return True

        except Exception as e:
            conn.rollback()
            logger.error(f"❌ Ошибка отключения 2FA для {user_id}: {e}")
            return False
        finally:
            cur.close()
            conn.close()

    @classmethod
    def get_with_2fa(cls, user_id: int) -> Optional[Dict[str, Any]]:
        """
        Получает пользователя с данными для 2FA.

        Args:
            user_id: ID пользователя

        Returns:
            Optional[Dict]: Данные пользователя (только для 2FA)
        """
        user = cls.get_by_id(user_id)
        if user:
            # Возвращаем только нужные для 2FA поля
            return {
                'id': user['id'],
                'username': user['username'],
                'twofa_enabled': user['twofa_enabled'],
                'twofa_secret': user['twofa_secret'] if user['twofa_enabled'] else None
            }
        return None
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
================================================================================
ФАЙЛ: models/message.py
НАЗНАЧЕНИЕ: Модель сообщения
АВТОР: Oliver Vance
ДАТА: 2026-02-14

ОПИСАНИЕ:
    Работа с таблицей messages:
    - Сохранение сообщений
    - Получение истории чата
    - Форматирование для вывода

ИСПОЛЬЗОВАНИЕ:
    from models.message import Message

    # Сохранить сообщение
    Message.save(chat_id=1, role='user', content='Привет')

    # Получить историю
    history = Message.get_chat_history(1)

ИСТОРИЯ ИЗМЕНЕНИЙ:
    2026-02-14 - Oliver - создание
================================================================================
"""

from typing import List, Dict, Any, Optional, Tuple

from utils.db import get_db_connection, get_dict_cursor, execute_insert
from models.base import BaseModel
from models.chat import Chat

import logging

logger = logging.getLogger(__name__)


class Message(BaseModel):
    """
    Модель сообщения.

    Таблица: messages
    Поля:
        id: SERIAL PRIMARY KEY
        chat_id: INTEGER NOT NULL REFERENCES chats(id) ON DELETE CASCADE
        role: VARCHAR(20) NOT NULL CHECK (role IN ('user', 'assistant'))
        content: TEXT NOT NULL
        created_at: TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    """

    table_name = 'messages'

    @classmethod
    def save(cls, chat_id: int, role: str, content: str) -> int:
        """
        Сохраняет сообщение в БД.

        Args:
            chat_id: ID чата
            role: 'user' или 'assistant'
            content: Текст сообщения

        Returns:
            int: ID сохранённого сообщения

        Raises:
            ValueError: Если роль недопустима
        """
        if role not in ['user', 'assistant']:
            raise ValueError(f"Недопустимая роль: {role}")

        conn = get_db_connection()
        try:
            # Сохраняем сообщение
            message_id = execute_insert(conn, 'messages', {
                'chat_id': chat_id,
                'role': role,
                'content': content
            })

            # Обновляем timestamp чата
            Chat.update_timestamp(chat_id)

            conn.commit()
            logger.debug(f"✅ Сообщение {message_id} сохранено в чат {chat_id} ({role})")
            return message_id

        except Exception as e:
            conn.rollback()
            logger.error(f"❌ Ошибка сохранения сообщения: {e}")
            raise
        finally:
            conn.close()

    @classmethod
    def get_chat_history(cls, chat_id: int, limit: int = 100) -> List[Tuple[str, str]]:
        """
        Получает историю сообщений чата.

        Args:
            chat_id: ID чата
            limit: Максимальное количество сообщений

        Returns:
            List[Tuple[str, str]]: Список (role, content)
        """
        conn = get_db_connection()
        cur = conn.cursor()

        try:
            query = """
                SELECT role, content
                FROM messages
                WHERE chat_id = %s
                ORDER BY created_at
                LIMIT %s
            """
            cur.execute(query, (chat_id, limit))
            history = cur.fetchall()

            logger.debug(f"Загружено {len(history)} сообщений для чата {chat_id}")
            return history

        finally:
            cur.close()
            conn.close()

    @classmethod
    def get_chat_history_dict(cls, chat_id: int, limit: int = 100) -> List[Dict[str, Any]]:
        """
        Получает историю сообщений в формате словарей.

        Args:
            chat_id: ID чата
            limit: Максимальное количество сообщений

        Returns:
            List[Dict]: Список сообщений с id, role, content, created_at
        """
        conn = get_db_connection()
        cur = get_dict_cursor(conn)

        try:
            query = """
                SELECT id, role, content, created_at
                FROM messages
                WHERE chat_id = %s
                ORDER BY created_at
                LIMIT %s
            """
            cur.execute(query, (chat_id, limit))
            history = cur.fetchall()

            return history

        finally:
            cur.close()
            conn.close()

    @classmethod
    def get_last_message(cls, chat_id: int) -> Optional[Dict[str, Any]]:
        """
        Получает последнее сообщение в чате.

        Args:
            chat_id: ID чата

        Returns:
            Optional[Dict]: Последнее сообщение или None
        """
        conn = get_db_connection()
        cur = get_dict_cursor(conn)

        try:
            query = """
                SELECT id, role, content, created_at
                FROM messages
                WHERE chat_id = %s
                ORDER BY created_at DESC
                LIMIT 1
            """
            cur.execute(query, (chat_id,))
            message = cur.fetchone()

            return message

        finally:
            cur.close()
            conn.close()

    @classmethod
    def count_in_chat(cls, chat_id: int) -> int:
        """
        Считает количество сообщений в чате.

        Args:
            chat_id: ID чата

        Returns:
            int: Количество сообщений
        """
        conn = get_db_connection()
        cur = conn.cursor()

        try:
            query = "SELECT COUNT(*) FROM messages WHERE chat_id = %s"
            cur.execute(query, (chat_id,))
            count = cur.fetchone()[0]

            return count

        finally:
            cur.close()
            conn.close()

    @classmethod
    def delete_all_in_chat(cls, chat_id: int) -> int:
        """
        Удаляет все сообщения в чате.

        Args:
            chat_id: ID чата

        Returns:
            int: Количество удалённых сообщений
        """
        conn = get_db_connection()
        cur = conn.cursor()

        try:
            cur.execute("DELETE FROM messages WHERE chat_id = %s", (chat_id,))
            deleted = cur.rowcount
            conn.commit()

            logger.info(f"✅ Удалено {deleted} сообщений из чата {chat_id}")
            return deleted

        except Exception as e:
            conn.rollback()
            logger.error(f"❌ Ошибка удаления сообщений чата {chat_id}: {e}")
            return 0
        finally:
            cur.close()
            conn.close()

    @classmethod
    def format_for_ai(cls, chat_id: int, max_messages: int = 20) -> List[Dict[str, str]]:
        """
        Форматирует историю для отправки в AI.

        Args:
            chat_id: ID чата
            max_messages: Максимальное количество сообщений

        Returns:
            List[Dict]: Сообщения в формате [{"role": "...", "content": "..."}]
        """
        history = cls.get_chat_history(chat_id, max_messages)

        formatted = []
        for role, content in history:
            formatted.append({
                "role": role,
                "content": content
            })

        return formatted